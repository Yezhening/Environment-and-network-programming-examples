# 环境和网络编程实例（Environment-and-network-programming-examples）

## 一、说明

- 均使用Linux操作系统环境（其他环境会额外说明）
- 均使用网际协议版本4（IPv4）

## 二、环境编程内容

（1）进程间通信（IPC）：IPC

内容：对大部分总结的进程间通信机制提供简单实现：12种

- 头文件全局变量：glov_h
- 源文件全局变量：glov_s
- 文件，PV操作：file_pv
- 管道：pipe
- 命名管道：fifo
- 信号：sig
- XSI信号量：sem_XSI
- POSIX信号量：sem_POSIX
- 消息队列：mq
- 共享内存：shm
- 套接字：socket（使用代码仓库中，“传输控制协议（TCP）简单版：TCP_simple”）
- 内存映射：mmap

说明

- 有详细步骤解析
- 只简单演示基础的操作，未考虑深层次的问题
- 对相关函数获取返回值进行错误处理，不相关函数不进行错误处理

持续更新

- 当前内容总结于代码仓库作者和《UNIX环境高级编程（第3版）》的一部分
- 在《UNIX网络编程（第3版）卷2：进程间通信》中，还有其他的进程间通信机制，在后面有时间阅读后，持续更新代码仓库和博客

（2）“加/卸载” Zend Framework 2：load_ZF2

现状：已存在旧生产项目，系统使用 Zend Framework 2（基于 PHP 的 Web MVC 框架，简称 ZF2）

目标：简化 ZF2 的配置

内容

1. 将 ZF2 的供应镜像可执行文件加载到内存，并**映射/解映射**到虚拟设备的一个分区
2. 将虚拟设备的文件系统**挂/卸载**到目录

实现

- 环境：**FreeBSD**（服务器）
- 语言：C/C++（程序）
- 核心：执行 Shell 命令（程序使用 UNIX -> FreeBSD 的系统调用）
- 要求：可靠（尽可能地考虑并处理错误情况）

说明

- 注释有详细解析

文件结构


- 文件夹：load_ZF2
- 源文件：main.cpp
- 可执行文件：main
- 说明文件：readme.txt
- 配置文件：setupvendor.conf
- ZF2 的供应镜像文件：ZF2VendorImage.bin（**因为是生产项目，未将该文件开源在代码仓库**）

拓展

- 该份实例实际上是在 UNIX/FreeBSD/Linux 环境使用 C/C++ 程序执行 Shell 命令的**特例**版本
- 看懂代码后，稍加修改，该份实例可以成为**通用**版本

## 三、网络编程内容

### 1.迭代改进内容

（1）传输控制协议（TCP）简单版：TCP_simple

- 使用传输控制协议（TCP）

- 一个服务端连接一个客户端

- 一次自动通信

（2）多进程版：multiprocess

- 使用传输控制协议（TCP）

- 一个服务端可连接多个客户端——增加

- 多次手动通信——增加

（3）IO复用版：IO_multiplexing

- 使用传输控制协议（TCP）
- 服务端多进程，一个服务端可连接多个客户端
- 用户在客户端终端输入，可多次手动通信
- 服务端可获取客户端地址的逻辑；更新部分函数使用、错误处理、注释和Makefile文件；为保证代码简洁，部分输入输出和字符串处理函数未进行错误检测——增加
- 3个客户端代码实例分别使用IO复用的select、poll和epoll技术，同时监听用户输入和网络接收，可即时接收服务端进程终止和服务端主机关机消息——增加
- 客户端使用shutdown()而不是close()关闭连接，当客户端主动关闭写半部连接后，服务端仍能够接收而不是丢弃批量输入的缓冲区数据——增加

（4）守护进程版：daemon_process

- 使用传输控制协议（TCP）
- 检测recv()返回值，遇到信号或网络中断会重启
- 为保证代码简洁，部分输入输出和字符串处理函数未获取返回值进行错误检测
- 服务端作为守护进程启动，设置无缓冲IO，标准输入、输出和错误重定向并实时记录到日志文本文件。在main()开头注释不调用create_daemon()，可不作为守护进程启动——增加
- 服务端使用signal()注册SIGCHLD信号处理函数（signal()函数对信号处理一次后，信号恢复默认行为，需要在信号处理函数中重新注册）。信号处理函数中使用可重入函数和保存并恢复旧errno方案，避免重入错误。父进程接收SIGCHLD信号后调用循环非阻塞waitpid()可处理同时终止的多个子进程，避免子进程成为僵尸进程——增加
- 服务端检测accept()慢系统调用的返回值，遇到信号中断会重启。在三次握手后且accept()返回前的时序，收到客户端RST重新连接，依据POSIX标准重启——增加
- 服务端设置套接字选项：SO_KEEPLIVE。客户端不发送数据也可以检测到服务端主机崩溃、主机崩溃后重启或网络不可达——增加
- 服务端设置套接字选项：SO_REUSEADDR。服务端Ctrl+C或意外中止后，不会经过TIME_WAIT状态，bind()不会报错：Address already in use，可立即重启服务端。连接套接字子进程正常运行，监听套接字父进程可立即重启。允许多个IP地址绑定同一个端口——增加
- 服务端多进程，一个服务端可并发连接多个客户端
- 服务端使用getpeername()而不是传递客户端sockaddr_in{}参数获取客户端地址——修改
- 用户在客户端终端输入，可多次手动通信
- 3个客户端代码实例分别使用IO复用的select、poll和epoll技术，同时监听用户输入和网络接收，可即时检测到服务端进程终止和服务端主机关机
- Makefile文件增加注释和生成.o目标文件逻辑——增加

### 2.其他内容

（1）用户数据报协议（UDP）简单版：UDP_simple

- 使用用户数据报协议（UDP）

- 一个服务端连接一个客户端

- 一次自动通信

## 四、主要参考资料

- 《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago

- 《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff
