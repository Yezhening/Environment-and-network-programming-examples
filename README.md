# 环境和网络编程实例（Environment-and-network-programming-examples）

## 一、说明

- 均使用Linux操作系统环境
- 均使用网际协议版本4（IPv4）

## 二、内容

### 1.迭代改进内容

（1）传输控制协议（TCP）简单版：TCP_simple

- 使用传输控制协议（TCP）

- 一个服务端连接一个客户端

- 一次自动通信

（2）多进程版：multiprocess

- 使用传输控制协议（TCP）

- 一个服务端可连接多个客户端——增加

- 多次手动通信——增加

（3）IO复用版：IO_multiplexing

- 使用传输控制协议（TCP）
- 服务端多进程，一个服务端可连接多个客户端
- 用户在客户端终端输入，可多次手动通信
- 服务端可获取客户端地址的逻辑；更新部分函数使用、错误处理、注释和Makefile文件；为保证代码简洁，部分输入输出和字符串处理函数未进行错误检测——增加
- 3个客户端代码实例分别使用IO复用的select、poll和epoll技术，同时监听用户输入和网络接收，可即时接收服务端进程终止和服务端主机关机消息——增加
- 客户端使用shutdown()而不是close()关闭连接，当客户端主动关闭写半部连接后，服务端仍能够接收而不是丢弃批量输入的缓冲区数据——增加

（4）守护进程版：daemon_process

- 使用传输控制协议（TCP）
- 检测recv()返回值，遇到信号或网络中断会重启
- 为保证代码简洁，部分输入输出和字符串处理函数未获取返回值进行错误检测
- 服务端作为守护进程启动，设置无缓冲IO，标准输入、输出和错误重定向并实时记录到日志文本文件。在main()开头注释不调用create_daemon()，可不作为守护进程启动——增加
- 服务端使用signal()注册SIGCHLD信号处理函数（signal()函数对信号处理一次后，信号恢复默认行为，需要在信号处理函数中重新注册）。信号处理函数中使用可重入函数和保存并恢复旧errno方案，避免重入错误。父进程接收SIGCHLD信号后调用循环非阻塞waitpid()可处理同时终止的多个子进程，避免子进程成为僵尸进程——增加
- 服务端检测accept()慢系统调用的返回值，遇到信号中断会重启。在三次握手后且accept()返回前的时序，收到客户端RST重新连接，依据POSIX标准重启——增加
- 服务端设置套接字选项：SO_KEEPLIVE。客户端不发送数据也可以检测到服务端主机崩溃、主机崩溃后重启或网络不可达——增加
- 服务端设置套接字选项：SO_REUSEADDR。服务端Ctrl+C或意外中止后，不会经过TIME_WAIT状态，bind()不会报错：Address already in use，可立即重启服务端。连接套接字子进程正常运行，监听套接字父进程可立即重启。允许多个IP地址绑定同一个端口——增加
- 服务端多进程，一个服务端可并发连接多个客户端
- 服务端使用getpeername()而不是传递客户端sockaddr_in{}参数获取客户端地址——修改
- 用户在客户端终端输入，可多次手动通信
- 3个客户端代码实例分别使用IO复用的select、poll和epoll技术，同时监听用户输入和网络接收，可即时检测到服务端进程终止和服务端主机关机
- Makefile文件增加注释和生成.o目标文件逻辑——增加

### 2.其他内容

（1）用户数据报协议（UDP）简单版：UDP_simple

- 使用用户数据报协议（UDP）

- 一个服务端连接一个客户端

- 一次自动通信

## 三、主要参考资料

- 《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago

- 《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff
